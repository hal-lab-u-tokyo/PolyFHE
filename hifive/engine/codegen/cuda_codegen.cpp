#include "hifive/engine/codegen/cuda_codegen.hpp"

#include "hifive/core/logger.hpp"
#include "hifive/engine/codegen/codegen_writer.hpp"

namespace hifive {
namespace engine {

std::string emit_signature(std::vector<hifive::core::VariableType> types,
                           std::string suffix = "") {
    if (types.size() == 0) {
        return "";
    }

    std::string signature = "";
    for (size_t i = 0; i < types.size(); i++) {
        hifive::core::VariableType type = types[i];
        if (type == hifive::core::VariableType::U64) {
            signature += "uint64_t " + suffix + std::to_string(i);
        } else if (type == hifive::core::VariableType::U64_PTR) {
            signature += "uint64_t *" + suffix + std::to_string(i);
        }
        signature += ", ";
    }

    // Remove the last comma and space
    if (signature.size() > 0) {
        signature.pop_back();
        signature.pop_back();
    }
    return signature;
}

void CudaCodegen::emit_kernel(std::shared_ptr<hifive::core::Graph>& graph,
                              std::string filename) {
    LOG_INFO("Start Emitting kernel\n");
    // Hash map to store the kernel signature
    m_cu_kernels = std::map<std::string, std::shared_ptr<CodeUnitKernel>>();

    // Iterate the graph and generate the kernel signature
    for (auto node : graph->get_nodes()) {
        if (node == nullptr) {
            continue;
        }

        std::string op_type = node->get_op_type();
        if (m_cu_kernels.contains(op_type)) {
            continue;
        }

        std::shared_ptr<CodeUnitKernel> cu = std::make_shared<CodeUnitKernel>();
        cu->op_type = node->get_op_type();
        cu->func_name = "kernel_" + node->get_op_type();
        cu->input_signature = emit_signature(node->get_input_types(), "in_");
        cu->output_signature = emit_signature(node->get_output_types(), "out_");
        m_cu_kernels[op_type] = cu;

        CodeWriter w;
        w << "// Define kernel for node: " << node->get_op_type() << "\n";
        w << "__global__ void " << cu->func_name << "(";
        w << cu->input_signature;
        if (cu->input_signature.size() > 0 && cu->output_signature.size() > 0) {
            w << ", ";
        }
        w << cu->output_signature;
        w << ")";
        w.block_begin();
        w << "extern __shared__ uint64_t shared[];\n";
        w.block_end();
        w << "\n";
        w.write_to_file(filename, true);
    }
}

bool CudaCodegen::run_on_graph(std::shared_ptr<hifive::core::Graph>& graph) {
    LOG_INFO("Running CudaCodegen\n");
    std::string filename = "build/gen_cuda_main.cu";

    CodeWriter w_include;
    w_include << "// This file is generated by HiFive\n";
    w_include << "#include <cuda.h>\n";
    w_include << "#include <cuda_runtime.h>\n";
    w_include << "#include <iostream>\n\n";
    w_include.write_to_file(filename);

    emit_kernel(graph, filename);

    CodeWriter w;
    w << "int main(int argc, char *argv[])";
    w.block_begin();
    w << "std::cout << \"Starting Benchmarking...\" << std::endl;\n";
    w << "// cuda_init();\n\n";

    w << "// Input arguments\n";
    std::shared_ptr<hifive::core::Node> init_node = graph->get_init_node();
    int i = 0;
    for (auto edge : init_node->get_out_edges()) {
        std::shared_ptr<hifive::core::Node> e = edge->get_dst();
        std::string name_h =
            "input" + std::to_string(i) + "_" + e->get_op_name() + "_h";
        std::string name_d =
            "input" + std::to_string(i) + "_" + e->get_op_name() + "_d";
        std::string name_size = "sizeof(uint64_t) * " +
                                std::to_string(edge->get_shape(0)) + " * " +
                                std::to_string(edge->get_shape(1));
        w << "// Edge: " << init_node->get_op_name() << " -> "
          << e->get_op_name() << "\n";
        w << "uint64_t *" << name_h << ";\n";
        w << "uint64_t *" << name_d << ";\n";
        w << "cudaMallocHost((void **)&" << name_h << ", " << name_size
          << ");\n";
        w << "cudaMalloc((void **)&" << name_d << ", " << name_size << ");\n";
        i++;
    }

    w << "\n// Output arguments\n";
    std::shared_ptr<hifive::core::Node> exit_node = graph->get_exit_node();
    i = 0;
    for (auto edge : exit_node->get_in_edges()) {
        std::shared_ptr<hifive::core::Node> e = edge->get_src();
        std::string name_h =
            "output" + std::to_string(i) + "_" + e->get_op_name() + "_h";
        std::string name_d =
            "output" + std::to_string(i) + "_" + e->get_op_name() + "_d";
        std::string name_size = "sizeof(uint64_t) * " +
                                std::to_string(edge->get_shape(0)) + " * " +
                                std::to_string(edge->get_shape(1));
        w << "// Edge: " << e->get_op_name() << " -> "
          << exit_node->get_op_name() << "\n";
        w << "uint64_t *" << name_h << ";\n";
        w << "uint64_t *" << name_d << ";\n";
        w << "cudaMallocHost((void **)&" << name_h << ", " << name_size
          << ");\n";
        w << "cudaMalloc((void **)&" << name_d << ", " << name_size << ");\n";
        i++;
    }

    w << "\n// Fill input arguments\n";

    w << "\n// Run the graph\n";

    w << "std::cout << \"Finished Benchmarking...\" << std::endl;\n";
    w.block_end();

    w.write_to_file(filename, true);
    return true;
}
} // namespace engine
} // namespace hifive